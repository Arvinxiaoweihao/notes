

----------------------------------------
变量									|
----------------------------------------
	# 变量的类型与内存大小
		char
			* 字符型,使用单引号声明,用于输出一个单一的字符
			* 1个字节
			* 它并不是把字符存储到内存单元,而是把字符对应的 ascii 编码存放到存储单元
			* 本质上就是一个字节的整形,下面两种声明方式都是正确的
				char c = 97;
				char c = 'a';
			* 花里胡哨
				printf("%d\n",'\023');      //\0开头表示八进制      19
				printf("%d\n",'\x15');      //\x开头表示十六进制    21
				printf("%d\n",'\0');        //\0还是0

		short
			* 短整型,2字节
		int
			* 整形,4字节
		long
			* 长整型
			* windows4字节
			* linux4字节(32位),8字节(64位)
		long long
			* 长长整型
			* 8字节
		
		float
			* 单精度浮点型
			* 4字节,7位有效数字
			* 1位符号,8位指数,23位小数
		

		double
			* 双精度浮点型
			* 8字节,15 - 16 位有效数字
			* 双精度浮点值,双精度是1位符号,11位指数,52位小数

		long double
			* 16字节

	

		unsigned
		signed
		
		void
			* 不可以定义 void 类型的普通变量,编译器不知道它是什么类型,无法分配内存空间
			* 但是可以定义 void 指针,因为指针的大小是可以确定的(传说中的万能指针)

		_Bool
		_Complex
		_Imaginary

		* 整形数据在内存中占的字节与所选择的OS有关
		* C标准并没有明确规定整形类型数据的长度,但 long 的长度不能低于 int, int 不能低于 short
		* 占位小的数据赋值给占位大的数据,没有问题,系统会有变量提示
		* 占位大的数据赋值给占位小的数据,会发生高位截断从而引发精度丢失的问题

		* 浮点类型变量是由有限的存储单元组成,因此只能提供有限的有效数字
		* 不在有效范围的数字将会被舍去,这样可能会产生一些误差
	
	
	# 常量默认类型
		* 数字通常以 int 类型表示,如果超出了 int 类型,编译器会先视其为 long int 类型
		* 如果超出了 long 可表示的最大值,编译器则视其为 unsigned long 类型
		* 如果还不不够大,编译器则将其视为 long long 或者 unsigned long long 类型
		* 前提是编译器能够识别这些类型
	
		* 八进制,十六进制也被视为 int 类型
		* 如果值太大,编译器会尝试使用 unsigned int ,long ,unsigned long ,long long ,unsigned long 类型
		
	
	# 指定常量数据类型
		* 在值后面添加L/l表示该常量是 long 数据类型
			15L;
		
		* 在职后天添加LL/ll表示该常量是 long long 数据类型
			15LL

		* 添加f/F后缀,是 float 的常量声明
			0.23F

		* 添加 u/U后缀 是 unsgined 常量类型声明
			5u
			5UL
			5ULL
		
		* 添加0b前缀,是二进制数据类型
			0B0101101
		
	
----------------------------------------
变量修饰符								|
----------------------------------------
	const
		* 常量

	volatile
		* 防止编译器优化代码

	extern
		* 声明一个变量,extern 生的变量没有建立存储空间
			extern int x;
		* 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候
	
	register
		* 定义寄存器变量,提高效率,register 是建议类型的指令,而不是命令类型的指令
		* 如果 CPU 有空闲的寄存器,那么 register 生效,反之 register 无效
	
	auto 
		* 局部变量修饰
		* 在函数内部的变量 int a = 10; 编译器会有 int a = 10 之前会加上auto的关键字
		* auto的出现意味着,当前变量的作用域为当前函数或代码段的局部变量,意味着当前变量会在内存栈上进行分配

	static
		* 静态变量修饰

----------------------------------------
类型转换								|
----------------------------------------
	# 显式转换
		* 大转小
			int num = 255;
			short s = (short)num;
		* 使用括号来完成强制转换,可能引发精度丢失的问题


	# 隐式转换
		* 小转大
			double a;
			int b = 0;
			a = b;			//编译器自动把b的值转换为double,在给a赋值

----------------------------------------
bool 类型								|
----------------------------------------
	# C语言中使用 0 表示 false,非 0 表示 true
	# C99提供了 #include<stdbool.h> 头文件,使C增加了 bool 关键字和 true / false 关键字
		bool flag = true;
		flag = false;

----------------------------------------
常量声明								|
----------------------------------------
	# 编译时替换常量
		#define name value

		* 在编译程序的时候,程序中的所有 name 都会被替换为 value
		* 这个过程称为编译时替换,在运行程序的时候,所有替换都已经完成
		* 这样定义的常量也被称为明示常量

		* 末尾不需要添加;,而且名称要大写
	
	# const 
		const int X = 5;

		* X 这个变量只读,不能修改


----------------------------------------
typedef 机制							|
----------------------------------------
	# typedef 机制允许开发者为现有的数据类型创建别名
		typedef char byte;
		/*
			1111 1111 源码
			1000 0000 反码
			1000 0001 补码
		*/
		byte x = 255;
		printf("%d",x);	//-1

----------------------------------------
可移植类型 stdint.h 和 inttypes.h		|
----------------------------------------
	//TODO



	

	